# 문제
<p>좋은 패스워드를 만드는것은 어려운 일이다. 대부분의 사용자들은 buddy처럼 발음하기 좋고 기억하기 쉬운 패스워드를 원하나, 이런 패스워드들은 보안의 문제가 발생한다. 어떤 사이트들은 xvtpzyo 같은 비밀번호를 무작위로 부여해 주기도 하지만, 사용자들은 이를 외우는데 어려움을 느끼고 심지어는 포스트잇에 적어 컴퓨터에 붙여놓는다. 가장 이상적인 해결법은 '발음이 가능한' 패스워드를 만드는 것으로 적당히 외우기 쉬우면서도 안전하게 계정을 지킬 수 있다.</p> 

<p>회사 FnordCom은 그런 패스워드 생성기를 만들려고 계획중이다. 당신은 그 회사 품질 관리 부서의 직원으로 생성기를 테스트해보고 생성되는 패스워드의 품질을 평가하여야 한다. 높은 품질을 가진 비밀번호의 조건은 다음과 같다.</p>

- 모음(a,e,i,o,u) 하나를 반드시 포함하여야 한다.
- 모음이 3개 혹은 자음이 3개 연속으로 오면 안 된다.
- 같은 글자가 연속적으로 두번 오면 안되나, ee 와 oo는 허용한다.

이 규칙은 완벽하지 않다;우리에게 친숙하거나 발음이 쉬운 단어 중에서도 품질이 낮게 평가되는 경우가 많이 있다.

# 입력
<p>입력은 여러개의 테스트 케이스로 이루어져 있다.
</p>
<p>각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 테스트할 패스워드가 주어진다.
/<p>
<p>마지막 테스트 케이스는 end이며, 패스워드는 한글자 이상 20글자 이하의 문자열이다. 또한 패스워드는 대문자를 포함하지 않는다.
</p>
# 출력
각 테스트 케이스를 '예제 출력'의 형태에 기반하여 품질을 평가하여라.

# 접근방법 및 시도들
- v1: 입력받아줄 문자열을 선언하고 루프(입력 - 입력값검사 - 출력) 형태로 작성했다.
> v1방식으로 푼 결과는 오답으로 나왔는데, 입력값을 쭉 받아놓고 결과를 출력하는걸 원하는 문제였기때문. 몇개가 입력될지 모르기 때문에 end문자열이 나올때까지 입력을 받아줘야하는데 그렇게 해주기 위해 링크드 리스트를 활용했다.(v2)

- v2: 입력받아줄 문자열 포인터와 결과값 다음 구조체 가리킬 포인터를 멤버로 선언한다. 메인에서 링크드 리스트 구조체의 포인터를 선언하고, 초기화 - 입력 - 입력값검사 - 루프(입력 - 입력값검사) - 출력 순으로 작성했다.
> v1의 문자열 체크방식만 가져오고 나머지부분을 뜯어고쳐야 했다. 메인에서 리스트 포인터로 선언하기에 동적할당이 필요하고 멤버인 문자열과 다음 리스트 포인터 역시 동적할당을 해줘야 쓸수있어서 동적할당을 까먹는 실수가 잦았다. 

# 포인트
- 링크드 리스트를 사용하려면 메인에서 구조체 포인터로 선언하고 동적할당 해주자. 
- 그리고 웬만하면 그걸 해주는(동적할당 및 0값으로 초기화 등)함수를 만들어주자 예)init_list(&list)
- 구조체 포인터로 선언해서 그 이름 그대로 넘겨줘도 멤버에 접근해서 값을 쓸수 있을것 같지만 그렇게 하면 세그폴트난다.(리턴값 없는 void의 경우)
- 따라서 위 예문처럼 포인터의 주소값을 넘겨줘서 처리할수있도록 하자.
- list의 content에 내용을 쓸때 다음에 쓰게될때 가리키게될 *next도 동적할당 같이 해두자. 이건 취향차일거같긴한데. 
- 링크드리스트는 그 포인터가 계속 다음으로 이동하기 때문에 시작점을 기억하도록 하는 임시 포인터변수를 선언해서, 초기 동적할당이 끝난 후 포인터의 값을 담아줄수 있도록 한다.
- 메모리 프리할때 순서는 멤버 -> 구조체 포인터 순

