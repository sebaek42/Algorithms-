# 문제
<p>우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x,y)로 표시된다. 두 사람 A 와 B의 덩치가 각각 (x,y), (p,q)라고 할 때 x>p 그리고 y>q 이라면 우리는 A의 덩치가 B의 덩치보다 "더 크다"고 말한다. 예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56,177), (45,165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다. 예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55,173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, "덩치"로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.</p>

<p>N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 "큰 덩치"의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다. 이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. </p>

# 입력
<p>첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다. 단, 2 ≤ N ≤ 50, 10 ≤ x,y ≤ 200 이다.</p>

# 출력
<p>여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.</p>

# 접근방법
typedef struct로 무게, 키, 등수를 멤버로 갖는 구조체 t_size를 선언하고 s_size별칭을 붙인다. i, j인덱스로 이중반복문을 통한 비교를 해서 조건에 해당할때 구조체 멤버인 등수를 하나씩 올려주는 식으로 해결했다.

# 어려웠던 점
<p>main에서 리턴값이 void인 함수 init_size, solve_size를 호출하는데, 매개변수로 그냥 구조체 포인터를 받도록 해서 문제가 발생했다. 읽는거라면 포인터만 가져가도 괜찮지만, 구조체 배열에 속한 구조체의 멤버들의 값을 새로 써야했기에 '포인터의 주소'를 받고, '받아온 주소에 역참조'하여 값을 넣어줘야 했는데 이를 지키지 않았기 때문이다. </p>
<p>또하나 삽질했던 점은 받은 구조체 배열의 주소값을 역참조하고 역참조한 배열에 인덱스로 접근하는걸 제대로 하려면 괄호의 위치가 매우 중요한데, 이를 헷갈렸기 때문이다. 아래 함수를 보면 구조체 배열의 주소값을 담는 list를 scanf의 인자로 넣어주기 위해 &(*list)[i].w 형태를 띄고 있다. 

```
void	init_size(s_size **list, int len)
{
	int i;

	i = 0;
	if (!(*list = malloc(sizeof(s_size) * len)))
		return ;
	while (i < len)
	{
		scanf("%d %d", &(*list)[i].w, &(*list)[i].h);
		(*list)[i].rank = 1;
		i++;
	}
}
```

일단 우린 구조체 배열의 주소를 list라는 이름에 담아줬다. scanf는 값을 담아오기 위해 변수의 주소값을 필요로 한다. 이를 list로 표현하려면, - *list : 구조체 배열의 주소에 역참조(*) -> 구조체 배열의 첫번째 포인터
- (*list)[i] : 구조체 배열의 인덱스에 접근. 이때 괄호의 위치 매우 중요. -> 구조체 배열속 i번째 구조체
- (*list)[i].w : i번째 구조체의 멤버 w에 접근
- &(*list)[i].w : scanf가 요구하는 변수의 '주소값'을 전달해주기 위해 &를 맨앞에 붙여줌.

괄호의 위치가 나를 많이 괴롭혔는데, 내가 한 실수는 &(*list[i]).w였다. 논리적으로 따져보며 괄호 위치를 생각해보는게 필요할것같다! 앞으론 좀 더 구조체사용에 주의하자.
