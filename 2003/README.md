## 문제

N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i]+A[i+1]+…+A[j-1]+A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N(1≤N≤10,000), M(1≤M≤300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A는 30,000을 넘지 않는 자연수이다.

## 출력

첫째 줄에 경우의 수를 출력한다.

## 예제 입력 1

```
4 2
1 1 1 1

```

## 예제 출력 1

```
3

```

## 예제 입력 2

```
10 5
1 2 3 4 2 5 3 1 1 2

```

## 예제 출력 2

```
3
```

# 접근방법

모든경우의 수를 다 구하면 시간초과가 발생한다.

연속 구간 속 수의 값을 효율적으로 구하려면? 조건에 따라 구간의 시작점과 끝점을 옮겨 주면 된다

총합은 0에서 시작

구간의 시작과 끝은 0에서 시작

총합이 찾고자 하는 M과 같거나 크다면 구간의 시작을 하나 올려주고 제외된 하나만큼 총합에서 값을 빼준다

총합이 M보다 작다면 구간의 끝을 하나 더 늘려주고 총합에 늘어난 구간 속 수를 합해준다

그런데 그 전에, 구간의 끝이   구간의 길이인 N과 같다면 반복루프 탈출한다

더해주고 난 뒤, 혹은 빼주고 난 뒤 값이 M과 같다면 count를 하나 증가시킨다.

# 코드

```c
#include <stdio.h>

int	solve(int arr[], int N, int M)
{
	int sum;
	int left;
	int right;
	int count;

	left = 0;
	right = 0;
	count = 0;
	sum = 0;
	while (1) {
		if (sum >= M)
			sum -= arr[left++];
		else if (right == N)
			break;
		else
			sum += arr[right++];
		if (sum == M)
			count++;
	}
	return count;
}

int main()
{
	int N;
	int M;
	int arr[10000];
	int i;

	scanf("%d %d", &N, &M);
	i = 0;
	while (i < N)
	{
		scanf("%d", &arr[i]);
		i++;
	}
	printf("%d", solve(arr, N, M));
}
```

알고리즘이 이해안된다면 코드를 거꾸로 읽어보자
