# 문제
<p>정보문화진흥원 정보 영재 동아리에서 동아리 활동을 하던 영수와 민혁이는 쉬는 시간을 틈타 숫자야구 게임을 하기로 했다.</p>

<p>영수는 1에서 9까지의 서로 다른 숫자 세 개로 구성된 세 자리 수를 마음속으로 생각한다. (예: 324)
민혁이는 1에서 9까지의 서로 다른 숫자 세 개로 구성된 세 자리 수를 영수에게 묻는다. (예: 123)
민혁이가 말한 세 자리 수에 있는 숫자들 중 하나가 영수의 세 자리 수의 동일한 자리에 위치하면 스트라이크 한 번으로 센다. 숫자가 영수의 세 자리 수에 있긴 하나 다른 자리에 위치하면 볼 한 번으로 센다.</p>
예) 영수가 324를 갖고 있으면 
- 429는 1 스트라이크 1 볼이다.
- 241은 0 스트라이크 2 볼이다.
- 924는 2 스트라이크 0 볼이다.
<p>영수는 민혁이가 말한 수가 몇 스트라이크 몇 볼인지를 답해준다.
민혁이가 영수의 세 자리 수를 정확하게 맞추어 3 스트라이크가 되면 게임이 끝난다. 아니라면 민혁이는 새로운 수를 생각해 다시 영수에게 묻는다.</p>
<p>현재 민혁이와 영수는 게임을 하고 있는 도중에 있다. 민혁이가 영수에게 어떤 수들을 물어보았는지, 그리고 각각의 물음에 영수가 어떤 대답을 했는지가 입력으로 주어진다. 이 입력을 바탕으로 여러분은 영수가 생각하고 있을 가능성이 있는 수가 총 몇 개인지를 알아맞혀야 한다.</p>

아래와 같은 경우를 생각해보자.  

- 민혁: 123
- 영수: 1 스트라이크 1 볼.
- 민혁: 356
- 영수: 1 스트라이크 0 볼.
- 민혁: 327
- 영수: 2 스트라이크 0 볼.
- 민혁: 489
- 영수: 0 스트라이크 1 볼.
이때 가능한 답은 324와 328, 이렇게 두 가지이다.

<p>영수는 동아리의 규율을 잘 따르는 착한 아이라 민혁이의 물음에 곧이곧대로 정직하게 답한다. 그러므로 영수의 답들에는 모순이 없다.</p>

<p>민혁이의 물음들과 각각의 물음에 대한 영수의 답이 입력으로 주어질 때 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력하는 프로그램을 작성하시오.</p>

# 입력
<p>첫째 줄에는 민혁이가 영수에게 몇 번이나 질문을 했는지를 나타내는 1 이상 100 이하의 자연수 N이 주어진다. 이어지는 N개의 줄에는 각 줄마다 민혁이가 질문한 세 자리 수와 영수가 답한 스트라이크 개수를 나타내는 정수와 볼의 개수를 나타내는 정수, 이렇게 총 세 개의 정수가 빈칸을 사이에 두고 주어진다.</p>

# 출력
<p>첫 줄에 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력한다.<p>

<br>예제 입력 
> 4
<br>123 1 1
<br>356 1 0
<br>327 2 0
<br>489 0 1

<br>예제 출력
>2

# 접근방법
뭔가 대단한 알고리즘이 있지않을까..경우의 수를 구하는거라 여러 케이스에 대해 분기가 일어나야 하나 같은 고민을 많이 했다. 결국 생각해낸건
- 1000개의 인덱스를 가지는 정수형 배열을 하나 선언하고 인덱스가 세자리수면서 각 자릿수가 0이아니고 중복되는 숫자가 없을경우엔 값을 1로, 그렇지 않을경우엔 0으로 초기화해준다. 이건 숫자야구게임상 가능한 숫자들을 1의 상태로 갖는 배열을 만들어준다는 의미.
- 이제 배열값이 1인 인덱스들과 입력받은 세자리 숫자의 각 자릿수를 비교해서 스트라이크와 볼의 숫자가 일치하지 않는 인덱스의 값을 0으로 세팅해준다.
- 이걸 케이스수만큼 반복해준다
- 123 부터 987인덱스중 값이 1로 남아있는 개수를 세서 리턴하고 출력해주면 끝

# 어려웠던 점
- 이차원배열의 주소값을 가지고가서 void 함수내에서 동적할당해주다가 실수를 했다. 
```
void	init_QA(int ***QA, int num)
{
	int i;
	int j;
	if (!((*QA) = malloc(sizeof(int *) * num)))
		return ;
	i = 0;
	while (i < num)
	{
		if (!((*QA)[i] = malloc(sizeof(int) * 3)))
			return ;
		scanf("%d %d %d", &(*QA)[i][0], &(*QA)[i][1], &(*QA)[i][2]);
		i++;
	}
}
```
일단 주소값을 받아온만큼 역참조해줘서 이차원 배열을 동적할당해주는것까진 잘 했었는데 그 다음에 일차원배열을 동적할당 해줄때 (**QA)로만 해줘서(뇌절...) 입력받을때 세그폴트가 떴다. 위에 처럼 (*QA)[i]를 하나하나 동적할당해줘야 가능함!
- 각자리숫자를 비교해서 스트라이크와 볼의 개수를 구할때 알고리즘에 문제가 있었다.
```
while (i < 3)
	{
		if (number[i] == tmp[i])
			strike++;
		j = 0;
		while (j < 3)
		{
			if (number[i] == tmp[j])
				ball++;
			j++;
		}
		i++;
	}
	ball = ball - strike;
```
저기서 j = i로 해줘서 문제가 발생했었다. 0,0 0,1 0,2 / 1,1 1,2 / 2,2 를 비교해서 볼체크가 제대로 되지않았다.j = 0으로해야 모든 볼을 체크할수있음.
- 이상한 컴파일오류?
```
test.c:20:22: error: expected ')'
void    init_case(int **case)
                        ^
test.c:20:15: note: to match this '('
void    init_case(int **case)
                 ^
test.c:20:22: error: parameter name omitted
void    init_case(int **case)
                        ^
test.c:24:10: error: expected expression
        if (!((*case) = malloc(sizeof(int) * 1000)))
                ^
test.c:30:6: error: expected expression
                        (*case)[i] = 1;
                          ^
test.c:32:6: error: expected expression
                        (*case)[i] = 0;
                          ^
test.c:95:22: error: expected ')'
int             solve_case(int *case, int **QA, int num)
```
매개변수이름을 case로 지정해줬더니 괄호를 붙여야한다는 컴파일오류가 발생했다. 이름을 case에서 num으로 바꿔줬더니 해결되었는데 알고보니 'case'는, for, while 같이 미리 정의된 이름이라 오류가 발생했던 것이였다. 코딩테스트에서 이렇게 시간쓰게되면 진짜 억울했을듯.

