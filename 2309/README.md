# 문제
<p>왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.<p>

<p>아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.<p>

<p>아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.<p>

# 입력
<p>아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.<p>

# 출력
<p>일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.<p>

# 예제 입력 1 
<br>20
<br>7
<br>23
<br>19
<br>10
<br>15
<br>25
<br>8
<br>13
# 예제 출력 1 
<br>7
<br>8
<br>10
<br>13
<br>19
<br>20
<br>23

# 접근방법
9명의 난쟁이 키를 다 더한값에 두명의 난쟁이 키를 뺐을때 100이 나오면 된다. 따라서 이중반복문을 사용하여 서로다른 난쟁이 두명의 키를 전체합에 빼주는걸 반복해서 답을 구할수있다.

# 어려웠던 점
로직은 의심할 여지가 없는데 자꾸 다른 결과값이 나왔다. 문제가 발생한 부분은 

```
void	solve_array(int *array)
{
	int i;
	int j;
	int sum;

	i = 0;
	sum = 0;
	while (i < 9)
	{
		sum += array[i];
		i++;
	}
	i = 0;
	while (i < 9)
	{
		j = 0;
		while (j < 9)
		{
			if (i != j)
			{
				sum = sum - (array[i] + array[j]);
				if (sum == 100)
				{
					array[i] = 999;
					array[j] = 999;
					sort_array(array);
					return ;
				}
				sum = sum + (array[i] + array[j]);
			}
			j++;
		}
		i++;
	}
}
```
위 코드 중 세번째 while이 나오는 구간에, sum = sum - (array[i] + array[j])로 sum값을 변형시켰으면서 그 뒤 조건에 맞지 않을때 다시 원래 sum값을 복구시켜주는 작업을 하지 않았기 때문에 발생했다.
결국, 다시 sum = sum + (array[i] + array[j])를 해줌으로 문제를 해결할 수 있었다.

# 깨달은 점
난쟁이의 키를 입력받는 공간을 int 포인터로 선언해서 9를 동적 할당하는 방법과 처음부터 int배열의 사이즈를 9로 잡아 선언하는 방법의 코딩방법이 꽤나 다르다는것을 깨달았다.
- 동적할당의 경우, void함수에 이름만 넘겨줄경우 원래 배열의 값을 변경해주지 못한다. 즉, 읽기만 가능하다. 값을 쓰기(write) 위해선 메인에서 선언한 포인터의 주소값을 넘겨줘야 한다. 즉, 이름앞에 &를 붙여 인자로 넘겨줘야한다는것. 이것은 넘겨받은 함수내에서 값을 쓰기 위해 역참조할수있는 주소를 알려주는것이므로, 실제 void 함수 내에선, 넘겨받은 인자에 일일이 역참조를 뜻하는 *을 붙여주고 괄호로 감싼뒤에야 값을 쓸수있다.
- 반면 처음부터 크기가 정해진 배열선언의 경우, void함수에 &를 붙여 주소값을 넘겨주려하면 에러가 발생한다. 배열의 크기까지 선언해주는건 뭔가 그 배열의 객체가 생성되는 느낌이다. 배열의 객체가 생성되어 단순히 그 이름만 넘겨주는 것으로 void 함수 내에서 간편하게 값을 읽고 쓸수있다. free역시 필요가 없다. 오히려 free를 해주면 에러가 발생한다. 동적할당을 해주질 않았으니 당연.. 메모리가 선언되는 영역이 다른것 같다.
